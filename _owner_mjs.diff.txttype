diff --git a/server/owner.mjs b/server/owner.mjs
index 9f4ec06..23d00a1 100644
--- a/server/owner.mjs
+++ b/server/owner.mjs
@@ -1872,7 +1872,7 @@ router.get('/motivation/day', (req, res) => {
       const ownerRow = db.prepare("SELECT settings_json FROM owner_settings WHERE id = 1").get();
       const savedSettings = ownerRow?.settings_json ? JSON.parse(ownerRow.settings_json) : {};
       settings = { ...OWNER_SETTINGS_DEFAULTS, ...savedSettings };
-      
+
       // Save snapshot
       const now = new Date().toISOString();
       db.prepare('INSERT INTO motivation_day_settings (business_day, settings_json, created_at) VALUES (?, ?, ?)').run(day, JSON.stringify(settings), now);
@@ -2158,193 +2158,199 @@ router.get('/motivation/day', (req, res) => {
     
     // ====================
     // STEP 5.5: Calculate POINTS (v2: zone_at_sale from presales, fallback to users.zone)
+    // ONLY in adaptive mode
     // ====================
-    // Points formula:
-    //   speed/cruise: points = (revenue_net / 1000) * k_product * k_zone(zone)
-    //   banana:       points = (revenue_net / 1000) * k_banana_zone(zone)
-    // Zone is taken from presales.zone_at_sale (historical) with fallback to users.zone
-    
-    // Get revenue by seller and boat_type, with zone_at_sale for historical accuracy
-    const revenueBySellerAndType = db.prepare(`
-      SELECT
-        ml.seller_id,
-        COALESCE(b.type, gb.type) AS boat_type,
-        p.zone_at_sale,
-        COALESCE(SUM(CASE WHEN ml.type IN ('SALE_PREPAYMENT_CASH','SALE_PREPAYMENT_CARD','SALE_PREPAYMENT_MIXED','SALE_ACCEPTED_CASH','SALE_ACCEPTED_CARD','SALE_ACCEPTED_MIXED') THEN ml.amount ELSE 0 END), 0) AS revenue_gross,
-        COALESCE(SUM(CASE WHEN ml.type = 'SALE_CANCEL_REVERSE' THEN ABS(ml.amount) ELSE 0 END), 0) AS refunds
-      FROM money_ledger ml
-      LEFT JOIN presales p ON p.id = ml.presale_id
-      LEFT JOIN boat_slots bs ON bs.id = p.boat_slot_id
-      LEFT JOIN generated_slots gs ON (p.slot_uid LIKE 'generated:%' AND gs.id = CAST(substr(p.slot_uid, 11) AS INTEGER))
-      LEFT JOIN boats b ON b.id = bs.boat_id
-      LEFT JOIN boats gb ON gb.id = gs.boat_id
-      WHERE ml.status = 'POSTED'
-        AND ml.kind = 'SELLER_SHIFT'
-        AND DATE(ml.business_day) = ?
-        AND ml.seller_id IS NOT NULL
-        AND ml.seller_id > 0
-        AND ml.type IN ('SALE_PREPAYMENT_CASH','SALE_PREPAYMENT_CARD','SALE_PREPAYMENT_MIXED','SALE_ACCEPTED_CASH','SALE_ACCEPTED_CARD','SALE_ACCEPTED_MIXED','SALE_CANCEL_REVERSE')
-      GROUP BY ml.seller_id, COALESCE(b.type, gb.type), p.zone_at_sale
-    `).all(day);
-    
-    // Get seller zones from users table (fallback for old data without zone_at_sale)
-    const sellerZones = db.prepare(`
-      SELECT id, zone FROM users WHERE role = 'seller'
-    `).all();
-    const sellerZoneMap = new Map((sellerZones || []).map(r => [Number(r.id), r.zone]));
-    
-    // Coefficients from settings
-    const k_speed = Number(settings.k_speed ?? 1.2);
-    const k_cruise = Number(settings.k_cruise ?? 3.0);
-    
-    // Zone coefficients for speed/cruise
-    const k_zone_hedgehog = Number(settings.k_zone_hedgehog ?? 1.3);
-    const k_zone_center = Number(settings.k_zone_center ?? 1.0);
-    const k_zone_sanatorium = Number(settings.k_zone_sanatorium ?? 0.8);
-    const k_zone_stationary = Number(settings.k_zone_stationary ?? 0.7);
-    
-    // Helper to get zone coefficient for speed/cruise
-    const getZoneK = (zone) => {
-      if (zone === 'hedgehog') return k_zone_hedgehog;
-      if (zone === 'center') return k_zone_center;
-      if (zone === 'sanatorium') return k_zone_sanatorium;
-      if (zone === 'stationary') return k_zone_stationary;
-      return 1.0; // fallback if no zone assigned
-    };
-    
-    // Banana zone coefficients
-    const k_banana_hedgehog = Number(settings.k_banana_hedgehog ?? 2.7);
-    const k_banana_center = Number(settings.k_banana_center ?? 2.2);
-    const k_banana_sanatorium = Number(settings.k_banana_sanatorium ?? 1.2);
-    const k_banana_stationary = Number(settings.k_banana_stationary ?? 1.0);
-    
-    // Helper to get banana coefficient by zone
-    const getBananaK = (zone) => {
-      if (zone === 'hedgehog') return k_banana_hedgehog;
-      if (zone === 'center') return k_banana_center;
-      if (zone === 'sanatorium') return k_banana_sanatorium;
-      if (zone === 'stationary') return k_banana_stationary;
-      return 1.0; // fallback if no zone assigned
-    };
-    
-    // Build points_by_user
-    const pointsByUserMap = new Map();
-    
-    // Initialize all active sellers with zero points
-    activeSellersList.forEach(s => {
-      const zone = sellerZoneMap.get(s.user_id) || null;
-      // Get seller motivation state for streak
-      const state = getSellerState(s.user_id);
-      const streakDays = state?.calibrated ? (state.streak_days || 0) : 0;
-      const kStreak = getStreakMultiplier(streakDays);
-      pointsByUserMap.set(s.user_id, {
-        user_id: s.user_id,
-        role: 'seller',
-        name: s.name,
-        zone,
-        revenue_total: s.revenue,
-        revenue_by_type: { speed: 0, cruise: 0, banana: 0 },
-        points_by_type: { speed: 0, cruise: 0, banana: 0 },
-        points_base: 0, // Before streak multiplier
-        points_total: 0, // After streak multiplier
-        calibrated: state?.calibrated || 0,
-        current_level: state?.current_level || 'NONE',
-        streak_days: streakDays,
-        k_streak: kStreak
-      });
-    });
-    
-    // Fill in revenue and calculate points by boat type
-    for (const row of (revenueBySellerAndType || [])) {
-      const sellerId = Number(row.seller_id);
-      const boatType = row.boat_type || null;
-      const zoneAtSale = row.zone_at_sale || null;  // Historical zone from presale
-      const revenueGross = Number(row.revenue_gross || 0);
-      const refunds = Number(row.refunds || 0);
-      const revenueNet = Math.max(0, revenueGross - refunds);
+    let pointsByUserMap = new Map();
+    let points_by_user = [];
+    
+    if (mode === 'adaptive') {
+      // Points formula:
+      //   speed/cruise: points = (revenue_net / 1000) * k_product * k_zone(zone)
+      //   banana:       points = (revenue_net / 1000) * k_banana_zone(zone)
+      // Zone is taken from presales.zone_at_sale (historical) with fallback to users.zone
       
-      if (!boatType || !['speed', 'cruise', 'banana'].includes(boatType)) continue;
+      // Get revenue by seller and boat_type, with zone_at_sale for historical accuracy
+      const revenueBySellerAndType = db.prepare(`
+        SELECT
+          ml.seller_id,
+          COALESCE(b.type, gb.type) AS boat_type,
+          p.zone_at_sale,
+          COALESCE(SUM(CASE WHEN ml.type IN ('SALE_PREPAYMENT_CASH','SALE_PREPAYMENT_CARD','SALE_PREPAYMENT_MIXED','SALE_ACCEPTED_CASH','SALE_ACCEPTED_CARD','SALE_ACCEPTED_MIXED') THEN ml.amount ELSE 0 END), 0) AS revenue_gross,
+          COALESCE(SUM(CASE WHEN ml.type = 'SALE_CANCEL_REVERSE' THEN ABS(ml.amount) ELSE 0 END), 0) AS refunds
+        FROM money_ledger ml
+        LEFT JOIN presales p ON p.id = ml.presale_id
+        LEFT JOIN boat_slots bs ON bs.id = p.boat_slot_id
+        LEFT JOIN generated_slots gs ON (p.slot_uid LIKE 'generated:%' AND gs.id = CAST(substr(p.slot_uid, 11) AS INTEGER))
+        LEFT JOIN boats b ON b.id = bs.boat_id
+        LEFT JOIN boats gb ON gb.id = gs.boat_id
+        WHERE ml.status = 'POSTED'
+          AND ml.kind = 'SELLER_SHIFT'
+          AND DATE(ml.business_day) = ?
+          AND ml.seller_id IS NOT NULL
+          AND ml.seller_id > 0
+          AND ml.type IN ('SALE_PREPAYMENT_CASH','SALE_PREPAYMENT_CARD','SALE_PREPAYMENT_MIXED','SALE_ACCEPTED_CASH','SALE_ACCEPTED_CARD','SALE_ACCEPTED_MIXED','SALE_CANCEL_REVERSE')
+        GROUP BY ml.seller_id, COALESCE(b.type, gb.type), p.zone_at_sale
+      `).all(day);
       
-      let entry = pointsByUserMap.get(sellerId);
-      if (!entry) {
-        // Seller not in activeSellersList but has revenue - add anyway
-        const zone = sellerZoneMap.get(sellerId) || null;
-        const state = getSellerState(sellerId);
+      // Get seller zones from users table (fallback for old data without zone_at_sale)
+      const sellerZones = db.prepare(`
+        SELECT id, zone FROM users WHERE role = 'seller'
+      `).all();
+      const sellerZoneMap = new Map((sellerZones || []).map(r => [Number(r.id), r.zone]));
+      
+      // Coefficients from settings
+      const k_speed = Number(settings.k_speed ?? 1.2);
+      const k_cruise = Number(settings.k_cruise ?? 3.0);
+      
+      // Zone coefficients for speed/cruise
+      const k_zone_hedgehog = Number(settings.k_zone_hedgehog ?? 1.3);
+      const k_zone_center = Number(settings.k_zone_center ?? 1.0);
+      const k_zone_sanatorium = Number(settings.k_zone_sanatorium ?? 0.8);
+      const k_zone_stationary = Number(settings.k_zone_stationary ?? 0.7);
+      
+      // Helper to get zone coefficient for speed/cruise
+      const getZoneK = (zone) => {
+        if (zone === 'hedgehog') return k_zone_hedgehog;
+        if (zone === 'center') return k_zone_center;
+        if (zone === 'sanatorium') return k_zone_sanatorium;
+        if (zone === 'stationary') return k_zone_stationary;
+        return 1.0; // fallback if no zone assigned
+      };
+      
+      // Banana zone coefficients
+      const k_banana_hedgehog = Number(settings.k_banana_hedgehog ?? 2.7);
+      const k_banana_center = Number(settings.k_banana_center ?? 2.2);
+      const k_banana_sanatorium = Number(settings.k_banana_sanatorium ?? 1.2);
+      const k_banana_stationary = Number(settings.k_banana_stationary ?? 1.0);
+      
+      // Helper to get banana coefficient by zone
+      const getBananaK = (zone) => {
+        if (zone === 'hedgehog') return k_banana_hedgehog;
+        if (zone === 'center') return k_banana_center;
+        if (zone === 'sanatorium') return k_banana_sanatorium;
+        if (zone === 'stationary') return k_banana_stationary;
+        return 1.0; // fallback if no zone assigned
+      };
+      
+      // Build points_by_user
+      pointsByUserMap = new Map();
+      
+      // Initialize all active sellers with zero points
+      activeSellersList.forEach(s => {
+        const zone = sellerZoneMap.get(s.user_id) || null;
+        // Get seller motivation state for streak
+        const state = getSellerState(s.user_id);
         const streakDays = state?.calibrated ? (state.streak_days || 0) : 0;
         const kStreak = getStreakMultiplier(streakDays);
-        entry = {
-          user_id: sellerId,
+        pointsByUserMap.set(s.user_id, {
+          user_id: s.user_id,
           role: 'seller',
-          name: `Seller #${sellerId}`,
+          name: s.name,
           zone,
-          revenue_total: 0,
+          revenue_total: s.revenue,
           revenue_by_type: { speed: 0, cruise: 0, banana: 0 },
           points_by_type: { speed: 0, cruise: 0, banana: 0 },
-          points_base: 0,
-          points_total: 0,
+          points_base: 0, // Before streak multiplier
+          points_total: 0, // After streak multiplier
           calibrated: state?.calibrated || 0,
           current_level: state?.current_level || 'NONE',
           streak_days: streakDays,
           k_streak: kStreak
-        };
-        pointsByUserMap.set(sellerId, entry);
-      }
-      
-      // Update revenue by type
-      entry.revenue_by_type[boatType] += revenueNet;
-      entry.revenue_total += revenueNet;
-      
-      // Use zone_at_sale if available, otherwise fallback to users.zone
-      const effectiveZone = zoneAtSale || entry.zone;
-      
-      // Calculate points (base, before streak multiplier)
-      const revenueInK = revenueNet / 1000;
-      let pointsBase = 0;
+        });
+      });
       
-      if (boatType === 'speed') {
-        pointsBase = revenueInK * k_speed * getZoneK(effectiveZone);
-      } else if (boatType === 'cruise') {
-        pointsBase = revenueInK * k_cruise * getZoneK(effectiveZone);
-      } else if (boatType === 'banana') {
-        const kBanana = getBananaK(effectiveZone);
-        pointsBase = revenueInK * kBanana;
+      // Fill in revenue and calculate points by boat type
+      for (const row of (revenueBySellerAndType || [])) {
+        const sellerId = Number(row.seller_id);
+        const boatType = row.boat_type || null;
+        const zoneAtSale = row.zone_at_sale || null;  // Historical zone from presale
+        const revenueGross = Number(row.revenue_gross || 0);
+        const refunds = Number(row.refunds || 0);
+        const revenueNet = Math.max(0, revenueGross - refunds);
+        
+        if (!boatType || !['speed', 'cruise', 'banana'].includes(boatType)) continue;
+        
+        let entry = pointsByUserMap.get(sellerId);
+        if (!entry) {
+          // Seller not in activeSellersList but has revenue - add anyway
+          const zone = sellerZoneMap.get(sellerId) || null;
+          const state = getSellerState(sellerId);
+          const streakDays = state?.calibrated ? (state.streak_days || 0) : 0;
+          const kStreak = getStreakMultiplier(streakDays);
+          entry = {
+            user_id: sellerId,
+            role: 'seller',
+            name: `Seller #${sellerId}`,
+            zone,
+            revenue_total: 0,
+            revenue_by_type: { speed: 0, cruise: 0, banana: 0 },
+            points_by_type: { speed: 0, cruise: 0, banana: 0 },
+            points_base: 0,
+            points_total: 0,
+            calibrated: state?.calibrated || 0,
+            current_level: state?.current_level || 'NONE',
+            streak_days: streakDays,
+            k_streak: kStreak
+          };
+          pointsByUserMap.set(sellerId, entry);
+        }
+        
+        // Update revenue by type
+        entry.revenue_by_type[boatType] += revenueNet;
+        entry.revenue_total += revenueNet;
+        
+        // Use zone_at_sale if available, otherwise fallback to users.zone
+        const effectiveZone = zoneAtSale || entry.zone;
+        
+        // Calculate points (base, before streak multiplier)
+        const revenueInK = revenueNet / 1000;
+        let pointsBase = 0;
+        
+        if (boatType === 'speed') {
+          pointsBase = revenueInK * k_speed * getZoneK(effectiveZone);
+        } else if (boatType === 'cruise') {
+          pointsBase = revenueInK * k_cruise * getZoneK(effectiveZone);
+        } else if (boatType === 'banana') {
+          const kBanana = getBananaK(effectiveZone);
+          pointsBase = revenueInK * kBanana;
+        }
+        
+        entry.points_by_type[boatType] += pointsBase;
+        entry.points_base += pointsBase;
       }
       
-      entry.points_by_type[boatType] += pointsBase;
-      entry.points_base += pointsBase;
-    }
-    
-    // Apply streak multiplier to points_total for each seller
-    for (const [sellerId, entry] of pointsByUserMap) {
-      if (entry.role === 'seller') {
-        entry.points_total = Math.round(entry.points_base * entry.k_streak * 100) / 100; // 2 decimal places
+      // Apply streak multiplier to points_total for each seller
+      for (const [sellerId, entry] of pointsByUserMap) {
+        if (entry.role === 'seller') {
+          entry.points_total = Math.round(entry.points_base * entry.k_streak * 100) / 100; // 2 decimal places
+        }
       }
-    }
-    
-    // Add dispatchers to points_by_user (they have 0 revenue/points but are participants)
-    for (const d of (dispatchersList || [])) {
-      const uid = Number(d.id);
-      if (!pointsByUserMap.has(uid)) {
-        pointsByUserMap.set(uid, {
-          user_id: uid,
-          role: 'dispatcher',
-          name: d.username,
-          zone: null,
-          revenue_total: 0,
-          revenue_by_type: { speed: 0, cruise: 0, banana: 0 },
-          points_by_type: { speed: 0, cruise: 0, banana: 0 },
-          points_base: 0,
-          points_total: 0,
-          calibrated: 0,
-          current_level: 'NONE',
-          streak_days: 0,
-          k_streak: 1.0
-        });
+      
+      // Add dispatchers to points_by_user (they have 0 revenue/points but are participants)
+      for (const d of (dispatchersList || [])) {
+        const uid = Number(d.id);
+        if (!pointsByUserMap.has(uid)) {
+          pointsByUserMap.set(uid, {
+            user_id: uid,
+            role: 'dispatcher',
+            name: d.username,
+            zone: null,
+            revenue_total: 0,
+            revenue_by_type: { speed: 0, cruise: 0, banana: 0 },
+            points_by_type: { speed: 0, cruise: 0, banana: 0 },
+            points_base: 0,
+            points_total: 0,
+            calibrated: 0,
+            current_level: 'NONE',
+            streak_days: 0,
+            k_streak: 1.0
+          });
+        }
       }
+      
+      points_by_user = Array.from(pointsByUserMap.values());
     }
     
-    const points_by_user = Array.from(pointsByUserMap.values());
-    
     // ====================
     // STEP 5.6: Build sales_points for map (lat/lng from presales)
     // ====================
@@ -2436,13 +2442,13 @@ router.get('/motivation/day', (req, res) => {
     const meaningfulPayouts = (Array.isArray(payouts) ? payouts : [])
       .filter(p => safeNum(p?.total) > 0);
     
-    // Enrich payouts with points_total and zone
+    // Enrich payouts with points_total and zone (only in adaptive mode)
     const payoutsWithPoints = meaningfulPayouts.map(payout => {
       const pointsEntry = pointsByUserMap.get(payout.user_id);
       return {
         ...payout,
-        points_total: pointsEntry?.points_total ?? 0,
-        zone: pointsEntry?.zone ?? null
+        points_total: mode === 'adaptive' ? (pointsEntry?.points_total ?? 0) : 0,
+        zone: mode === 'adaptive' ? (pointsEntry?.zone ?? null) : null
       };
     });
     
@@ -2479,10 +2485,10 @@ router.get('/motivation/day', (req, res) => {
         active_dispatchers_count: activeDispatchersCount,
         dispatcher_daily_bonus_total: dispatcherDailyBonusTotal,
         payouts: payoutsWithPoints,
-        // Points calculation (v3: with streak multiplier)
-        points_enabled: true,
-        points_rule: 'v3_zone_at_sale_fallback_user_zone_streak_multiplier',
-        points_by_user,
+        // Points calculation (v3: with streak multiplier) - only in adaptive mode
+        points_enabled: mode === 'adaptive',
+        points_rule: mode === 'adaptive' ? 'v3_zone_at_sale_fallback_user_zone_streak_multiplier' : null,
+        points_by_user: mode === 'adaptive' ? points_by_user : [],
         // Sales points for map visualization
         sales_points: salesPoints || []
       },
